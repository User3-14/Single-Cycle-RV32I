Heads up: we wrote a Java program that took the list of instructions as input and generated the corresponding instruction memory initialization VHDL code.

00000000010100000000000010010011 ; 00000000010100001001000100010011 ; 00000000001000001110000110110011 ; 11111111101000001000001000010011 ; 00000000010000011100001010110011 ; 00000000001000001100010001100011 ; 11111111111100000000001100010011 ; 00000000000100000000001100010011 ; 00000000010000001001000000100011 ; 11111111111100001100001110000011 

8:  addi x1, x0, 5	// x1 = 0X00000005;
12: slli x2, x1, 5	// x2 = 0X000000A0;
16: or x3, x1, x2	// x3 = 0X000000A5;
20: addi x4, x1, -6	// x4 = 0XFFFFFFFF;
24: xor x5, x3, x4	// x5 = 0XFFFFFF5A;
28: blt x1, x2, 8	// skip next
32: addi x6, x0, -1	// x6 = 0XFFFFFFFF;
36: addi x6, x0, 1	// x6 = 0X00000001;
40: sh x4, 0(x1)	// MEM[5] = 0X0000FFFF;
44: lbu x7, -1(x1)	// x7 = 0X000000FF;

--------------------------------------------------

    addi x1, x0, 5        # x1 = 5
    addi x2, x0, 10       # x2 = 10
    add  x3, x1, x2       # x3 = x1 + x2 = 15
    sub  x4, x3, x1       # x4 = x3 - x1 = 10
    sw   x4, 0(x0)        # Store x4 to address 0
    lw   x5, 0(x0)        # Load from address 0 to x5
    beq  x4, x5, skip     # If x4 == x5, branch to skip
    addi x6, x0, 1        # (Should be skipped if branch works)
skip:
    nop                   # End of program

Binary:
00000000010100000000000010010011 ; 00000000101000000000000100010011 ; 00000000001000001000000110110011 ; 01000000000100011000001000110011 ; 00000000010000000010000000100011 ; 00000000000000000010001010000011 ; 00000000010100100000010001100011 ; 00000000000100000000001100010011 ; 00000000000000000000000000010011 ; 
